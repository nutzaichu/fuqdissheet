<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: valueTransformer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: valueTransformer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module InputRange/valueTransformer
 */

import { clamp, isEmpty, isNumber, objectOf } from './util';

/**
 * Convert position into percentage value
 * @static
 * @param {InputRange} inputRange
 * @param {Point} position
 * @return {number} Percentage value
 */
function percentageFromPosition(inputRange, position) {
  const length = inputRange.trackClientRect.width;
  const sizePerc = position.x / length;

  return sizePerc || 0;
}

/**
 * Convert position into model value
 * @static
 * @param {InputRange} inputRange
 * @param {Point} position
 * @return {number} Model value
 */
function valueFromPosition(inputRange, position) {
  const sizePerc = percentageFromPosition(inputRange, position);
  const valueDiff = inputRange.props.maxValue - inputRange.props.minValue;
  const value = inputRange.props.minValue + valueDiff * sizePerc;

  return value;
}

/**
 * Extract values from props
 * @static
 * @param {InputRange} inputRange
 * @param {Point} [props=inputRange.props]
 * @return {Range} Range values
 */
function valuesFromProps(inputRange, { props } = inputRange) {
  if (inputRange.isMultiValue) {
    let values = props.value;

    if (isEmpty(values) || !objectOf(values, isNumber)) {
      values = props.defaultValue;
    }

    return Object.create(values);
  }

  const value = isNumber(props.value) ? props.value : props.defaultValue;

  return {
    min: props.minValue,
    max: value,
  };
}

/**
 * Convert value into percentage value
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {number} Percentage value
 */
function percentageFromValue(inputRange, value) {
  const validValue = clamp(value, inputRange.props.minValue, inputRange.props.maxValue);
  const valueDiff = inputRange.props.maxValue - inputRange.props.minValue;
  const valuePerc = (validValue - inputRange.props.minValue) / valueDiff;

  return valuePerc || 0;
}

/**
 * Convert values into percentage values
 * @static
 * @param {InputRange} inputRange
 * @param {Range} values
 * @return {Range} Percentage values
 */
function percentagesFromValues(inputRange, values) {
  const percentages = {
    min: percentageFromValue(inputRange, values.min),
    max: percentageFromValue(inputRange, values.max),
  };

  return percentages;
}

/**
 * Convert value into position
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {Point} Position
 */
function positionFromValue(inputRange, value) {
  const length = inputRange.trackClientRect.width;
  const valuePerc = percentageFromValue(inputRange, value);
  const positionValue = valuePerc * length;

  return {
    x: positionValue,
    y: 0,
  };
}

/**
 * Convert a range of values into positions
 * @static
 * @param {InputRange} inputRange
 * @param {Range} values
 * @return {Object.&lt;string, Point>}
 */
function positionsFromValues(inputRange, values) {
  const positions = {
    min: positionFromValue(inputRange, values.min),
    max: positionFromValue(inputRange, values.max),
  };

  return positions;
}

/**
 * Extract a position from an event
 * @static
 * @param {InputRange} inputRange
 * @param {Event} event
 * @return {Point}
 */
function positionFromEvent(inputRange, event) {
  const trackClientRect = inputRange.trackClientRect;
  const length = trackClientRect.width;
  const { clientX } = event.touches ? event.touches[0] : event;
  const position = {
    x: clamp(clientX - trackClientRect.left, 0, length),
    y: 0,
  };

  return position;
}

/**
 * Convert a value into a step value
 * @static
 * @param {InputRange} inputRange
 * @param {number} value
 * @return {number} Step value
 */
function stepValueFromValue(inputRange, value) {
  return Math.round(value / inputRange.props.step) * inputRange.props.step;
}

export default {
  percentageFromPosition,
  percentageFromValue,
  percentagesFromValues,
  positionFromEvent,
  positionFromValue,
  positionsFromValues,
  stepValueFromValue,
  valueFromPosition,
  valuesFromProps,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-InputRange.html">InputRange</a></li><li><a href="module-InputRange_defaultClassNames.html">InputRange/defaultClassNames</a></li><li><a href="module-InputRange_Label.html">InputRange/Label</a></li><li><a href="module-InputRange_maxMinValuePropType.html">InputRange/maxMinValuePropType</a></li><li><a href="module-InputRange_Slider.html">InputRange/Slider</a></li><li><a href="module-InputRange_Track.html">InputRange/Track</a></li><li><a href="module-InputRange_util.html">InputRange/util</a></li><li><a href="module-InputRange_valueTransformer.html">InputRange/valueTransformer</a></li></ul><h3>Classes</h3><ul><li><a href="module-InputRange.html">InputRange</a></li><li><a href="module-InputRange_Label.html">InputRange/Label</a></li><li><a href="module-InputRange_Slider.html">InputRange/Slider</a></li><li><a href="module-InputRange_Track.html">InputRange/Track</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Jan 01 2016 10:22:08 GMT+1100 (AEDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
